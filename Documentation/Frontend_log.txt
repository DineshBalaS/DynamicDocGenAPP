## Initial Phase: Project Setup & Foundation üèóÔ∏è
The goal of this phase is to create a clean, organized, and scalable starting point for your React application, with all necessary configurations in place to support your AWS deployment plan.

1. Finalize Project Setup This step ensures your local development environment is ready and mirrors the structure we've planned.

Initialize Project: You've already done this by creating a Vite + React project and initializing Tailwind CSS.

Install Core Dependencies: We'll install the essential libraries for handling API calls and navigation. Open your terminal in the AkkaApp folder and run:

Bash

npm install axios react-router-dom

Create Folder Structure: Inside your src/ directory, create the planned folders: api, components, hooks, and pages. This organizes your code for the rest of the project.

2. Configure for AWS Deployment Based on your decision to use AWS, we'll configure the project to work seamlessly with your ECR/App Runner backend. The clear choice for your frontend is AWS Amplify, which is designed to host modern web apps and connects directly to your code repository for easy, continuous deployment.

Set Environment Variables: In the root of your frontend project, create a file named .env. Inside it, add the URL for your local Flask backend:

REACT_APP_API_BASE_URL=http://127.0.0.1:5000
This tells your app where to send API requests when you're developing on your machine. When you deploy to AWS Amplify, you will set this same variable in the Amplify console to point to your live AWS App Runner URL.

Simplify CORS Policy: Since you won't use a separate staging environment, your backend's CORS policy is now much simpler. It only needs to allow requests from two places: http://localhost:5173 (your Vite dev server) and the final https://your-app-name.amplifyapp.com URL.

3. Establish the API Service Layer This creates a clean, dedicated place for all backend communication, making the code much easier to manage.

Create Axios Instance: In src/api/, create a file named axiosConfig.js. This file will set up a central axios instance that automatically uses the REACT_APP_API_BASE_URL from your .env file.

Define API Functions: In src/api/, create the templateService.js file. Here, you'll write the functions that will call your backend endpoints, like getTemplates() and uploadForAnalysis().

4. Implement Basic Error Handling & Logging Per your request, we'll set up a simple but effective way to handle errors.

Create a Toast Component: In src/components/ui/, create a basic Toast.jsx component. This component will be used to display subtle, simple error messages to the user when an API call fails.


Implement Console Logging: In your templateService.js functions, we will wrap all API calls in try...catch blocks. If an error occurs, we will show the toast notification to the user and log the detailed technical error to the browser's console. This provides the "log" the client can use for debugging without needing a complex external service.

By the end of this phase, you'll have a robust project foundation that is correctly configured for your AWS deployment target, with a clean structure ready for building the visual components.

## Phase 2 Checklist & Plan
Here is a step-by-step plan for building the static UI, including how we'll test each part.

### Step 1: Create the Main Application Layout
We'll start by creating the main frame of the application‚Äîthe header and content area‚Äîto ensure a consistent look on every page.

Implementation:

Create a Header.jsx component in src/components/common/. This will contain your app's title or logo.

Create a MainLayout.jsx component in src/components/layout/. This component will render the Header at the top and then render the specific page content below it.

Update App.jsx to wrap all your page routes within this MainLayout component.

Testing & Verification:

‚úÖ Visual Check: When you run the app, you should see your new header permanently fixed at the top of the page.

‚úÖ Navigation Check: As you navigate between the homepage (/) and the upload page (/upload), the content below the header should change, but the header itself should remain in place.

### Step 2: Build the Static Dashboard Page
Next, we'll build the main dashboard that users will see, which primarily consists of a grid of template cards.

Implementation:

Create a TemplateCard.jsx component in src/components/templates/. It will be a styled card that accepts props like a template name.

In src/pages/DashboardPage.jsx, create a hardcoded array of fake data (e.g., const mockTemplates = [{ id: 1, name: 'Monthly Business Review' }, { id: 2, name: 'Client Proposal' }];).

Use this mockTemplates array to render a grid of your TemplateCard components.

Add the styled + Upload New Template button to the page.

Testing & Verification:

‚úÖ Visual Check: The dashboard should display a styled grid of template cards, each showing the name from your hardcoded data, perfectly matching your UI design.

### Step 3: Build the Multi-Step Upload Workflow
This is the most interactive part of the static build. We'll create the three-step process for uploading a new template within a single page component.

Implementation:

In src/pages/UploadWorkflowPage.jsx, use a React state (useState) to track the current step (e.g., step 1, step 2, step 3).

Use conditional rendering to show the UI for the active step and hide the others.

Step 1 UI: Build the initial file upload screen with a prominent upload button or drag-and-drop area.

Step 2 UI: Build the placeholder review screen. Create a PlaceholderTag.jsx component in src/components/templates/ and use a hardcoded array of strings (e.g., ['name', 'date']) to display the tags.

Step 3 UI: Build the final save screen with the "Template Name" input and the "Save Template" and "Generate Now" buttons.

Testing & Verification:

‚úÖ Interaction Check: You should be able to click through the workflow. Clicking the "Upload" button takes you to step 2, and clicking "Confirm & Continue" takes you to step 3.

‚úÖ Visual Check: Each step should appear exactly as designed in your UI documents, with all buttons, inputs, and placeholder tags correctly styled.

After completing these steps, you will have a fully styled, clickable prototype of your application, ready for backend integration in Phase 3.