## Initial Phase: Project Setup & Foundation üèóÔ∏è
The goal of this phase is to create a clean, organized, and scalable starting point for your React application, with all necessary configurations in place to support your AWS deployment plan.

1. Finalize Project Setup This step ensures your local development environment is ready and mirrors the structure we've planned.

Initialize Project: You've already done this by creating a Vite + React project and initializing Tailwind CSS.

Install Core Dependencies: We'll install the essential libraries for handling API calls and navigation. Open your terminal in the AkkaApp folder and run:

Bash

npm install axios react-router-dom

Create Folder Structure: Inside your src/ directory, create the planned folders: api, components, hooks, and pages. This organizes your code for the rest of the project.

2. Configure for AWS Deployment Based on your decision to use AWS, we'll configure the project to work seamlessly with your ECR/App Runner backend. The clear choice for your frontend is AWS Amplify, which is designed to host modern web apps and connects directly to your code repository for easy, continuous deployment.

Set Environment Variables: In the root of your frontend project, create a file named .env. Inside it, add the URL for your local Flask backend:

REACT_APP_API_BASE_URL=http://127.0.0.1:5000
This tells your app where to send API requests when you're developing on your machine. When you deploy to AWS Amplify, you will set this same variable in the Amplify console to point to your live AWS App Runner URL.

Simplify CORS Policy: Since you won't use a separate staging environment, your backend's CORS policy is now much simpler. It only needs to allow requests from two places: http://localhost:5173 (your Vite dev server) and the final https://your-app-name.amplifyapp.com URL.

3. Establish the API Service Layer This creates a clean, dedicated place for all backend communication, making the code much easier to manage.

Create Axios Instance: In src/api/, create a file named axiosConfig.js. This file will set up a central axios instance that automatically uses the REACT_APP_API_BASE_URL from your .env file.

Define API Functions: In src/api/, create the templateService.js file. Here, you'll write the functions that will call your backend endpoints, like getTemplates() and uploadForAnalysis().

4. Implement Basic Error Handling & Logging Per your request, we'll set up a simple but effective way to handle errors.

Create a Toast Component: In src/components/ui/, create a basic Toast.jsx component. This component will be used to display subtle, simple error messages to the user when an API call fails.


Implement Console Logging: In your templateService.js functions, we will wrap all API calls in try...catch blocks. If an error occurs, we will show the toast notification to the user and log the detailed technical error to the browser's console. This provides the "log" the client can use for debugging without needing a complex external service.

By the end of this phase, you'll have a robust project foundation that is correctly configured for your AWS deployment target, with a clean structure ready for building the visual components.

## Phase 2 Checklist & Plan
Here is a step-by-step plan for building the static UI, including how we'll test each part.

### Step 1: Create the Main Application Layout
We'll start by creating the main frame of the application‚Äîthe header and content area‚Äîto ensure a consistent look on every page.

Implementation:

Create a Header.jsx component in src/components/common/. This will contain your app's title or logo.

Create a MainLayout.jsx component in src/components/layout/. This component will render the Header at the top and then render the specific page content below it.

Update App.jsx to wrap all your page routes within this MainLayout component.

Testing & Verification:

‚úÖ Visual Check: When you run the app, you should see your new header permanently fixed at the top of the page.

‚úÖ Navigation Check: As you navigate between the homepage (/) and the upload page (/upload), the content below the header should change, but the header itself should remain in place.

### Step 2: Build the Static Dashboard Page
Next, we'll build the main dashboard that users will see, which primarily consists of a grid of template cards.

Implementation:

Create a TemplateCard.jsx component in src/components/templates/. It will be a styled card that accepts props like a template name.

In src/pages/DashboardPage.jsx, create a hardcoded array of fake data (e.g., const mockTemplates = [{ id: 1, name: 'Monthly Business Review' }, { id: 2, name: 'Client Proposal' }];).

Use this mockTemplates array to render a grid of your TemplateCard components.

Add the styled + Upload New Template button to the page.

Testing & Verification:

‚úÖ Visual Check: The dashboard should display a styled grid of template cards, each showing the name from your hardcoded data, perfectly matching your UI design.

### Step 3: Build the Multi-Step Upload Workflow
This is the most interactive part of the static build. We'll create the three-step process for uploading a new template within a single page component.

Implementation:

In src/pages/UploadWorkflowPage.jsx, use a React state (useState) to track the current step (e.g., step 1, step 2, step 3).

Use conditional rendering to show the UI for the active step and hide the others.

Step 1 UI: Build the initial file upload screen with a prominent upload button or drag-and-drop area.

Step 2 UI: Build the placeholder review screen. Create a PlaceholderTag.jsx component in src/components/templates/ and use a hardcoded array of strings (e.g., ['name', 'date']) to display the tags.

Step 3 UI: Build the final save screen with the "Template Name" input and the "Save Template" and "Generate Now" buttons.

Testing & Verification:

‚úÖ Interaction Check: You should be able to click through the workflow. Clicking the "Upload" button takes you to step 2, and clicking "Confirm & Continue" takes you to step 3.

‚úÖ Visual Check: Each step should appear exactly as designed in your UI documents, with all buttons, inputs, and placeholder tags correctly styled.

After completing these steps, you will have a fully styled, clickable prototype of your application, ready for backend integration in Phase 3.

## The Goal of Phase 3 üîó
The goal of this phase is to systematically connect your frontend to your backend, replacing every piece of mock data and static functionality with live API calls. By the end of this phase, your application will be fully functional, capable of uploading, saving, listing, deleting, and generating presentations.

## Phase 3 Integration Plan & Checklist
Here is a step-by-step plan. We will focus on one feature at a time, implement the frontend logic, and verify it works before moving to the next.

### Step 1: Connect the Dashboard to GET /api/templates
First, we'll make the dashboard display real templates from your database.

Implementation:

In src/pages/DashboardPage.jsx, import getTemplates from your templateService.js file.

Use a useEffect hook to call this function when the component first loads.

Use a useState hook to store the fetched templates.

Replace the mockTemplates array with this new state variable. The component will now render real data.

Add loading and error states: display a spinner while fetching and an error message if the API call fails.

Verification:

‚úÖ Visual Check: The dashboard should now display the actual templates that exist in your PostgreSQL database. If the database is empty, it should show an empty screen (which we'll improve later) instead of the mock data.

### Step 2: Implement the Full Template Upload Workflow
This is the most complex step, connecting all three parts of the upload page to three different backend endpoints.

Implementation:

File Analysis (POST /api/upload): In UploadWorkflowPage.jsx, when a user selects a file in Step 1, we will call a new uploadForAnalysis function in templateService.js. This function will send the file and receive the list of placeholders, which we'll store in state.

State Management: The placeholder list from the API response will now populate the review screen in Step 2, replacing the mock data.

Template Saving (POST /api/save_template): In Step 3, when the user clicks "Save Template," we'll call a new saveTemplate function in templateService.js. This function must send multipart/form-data containing the template name, the final list of placeholders (as a JSON string), and the original file itself. On success, we will navigate the user back to the dashboard.

Verification:

‚úÖ End-to-End Test: Perform a full upload. Select a .pptx file, review the auto-detected placeholders, give it a name, and click "Save." You should be redirected to the dashboard, where your new template now appears in the list. Check your S3 bucket and database to confirm the records were created.

### Step 3: Implement Template Deletion (DELETE /api/templates/<id>)
Next, we'll activate the delete functionality on the dashboard.

Implementation:

Create a deleteTemplate function in templateService.js.

On the DashboardPage.jsx, add an onClick handler to the "delete" button (or the kebab menu option) on each TemplateCard.

This handler will show a confirmation modal ("Are you sure?"). If the user confirms, it will call the deleteTemplate function with the template's ID.

On success, it will refresh the list of templates to show that the item has been removed.

Verification:

‚úÖ Interaction Check: Go to the dashboard, delete a template, and confirm the action in the modal. The card should disappear from the UI. A subsequent page refresh should confirm it's gone. Check your database to confirm the deleted_at timestamp is set.

### Step 4: Implement the Presentation Generation Workflow
This final step connects the data entry form to the /generate endpoint and handles the file download.

Implementation:

Data Entry Page: We will create the DataEntryPage.jsx. This page will receive a templateId from the URL. It will fetch the template details (including its placeholders array) to dynamically build the form.

Asset Uploads (POST /api/assets/upload): For image placeholders, the file input's onChange handler will immediately call a new uploadAsset function in templateService.js. This function will upload the image and return the temporary s3_key, which we'll store in our form's state.

Generation (POST /api/generate): When the user clicks the final "Generate Presentation" button, we will call a generatePresentation function in templateService.js. This function will send a JSON payload containing the templateId and the data object (which includes the text values and the s3_keys for images).

File Download: The generatePresentation function must be configured to handle a blob response from the server. We will write the utility code to take this blob and trigger a browser download prompt for the user.

Verification:

‚úÖ End-to-End Test: Select a template from the dashboard. Fill out the dynamic form, including uploading an image. Click "Generate Presentation." A loading spinner should appear, followed by a browser download prompt for the finished .pptx file. Open the downloaded file to confirm all placeholders were correctly filled.