## Initial Phase: Project Setup & Foundation üèóÔ∏è
The goal of this phase is to create a clean, organized, and scalable starting point for your React application, with all necessary configurations in place to support your AWS deployment plan.

1. Finalize Project Setup This step ensures your local development environment is ready and mirrors the structure we've planned.

Initialize Project: You've already done this by creating a Vite + React project and initializing Tailwind CSS.

Install Core Dependencies: We'll install the essential libraries for handling API calls and navigation. Open your terminal in the AkkaApp folder and run:

Bash

npm install axios react-router-dom

Create Folder Structure: Inside your src/ directory, create the planned folders: api, components, hooks, and pages. This organizes your code for the rest of the project.

2. Configure for AWS Deployment Based on your decision to use AWS, we'll configure the project to work seamlessly with your ECR/App Runner backend. The clear choice for your frontend is AWS Amplify, which is designed to host modern web apps and connects directly to your code repository for easy, continuous deployment.

Set Environment Variables: In the root of your frontend project, create a file named .env. Inside it, add the URL for your local Flask backend:

REACT_APP_API_BASE_URL=http://127.0.0.1:5000
This tells your app where to send API requests when you're developing on your machine. When you deploy to AWS Amplify, you will set this same variable in the Amplify console to point to your live AWS App Runner URL.

Simplify CORS Policy: Since you won't use a separate staging environment, your backend's CORS policy is now much simpler. It only needs to allow requests from two places: http://localhost:5173 (your Vite dev server) and the final https://your-app-name.amplifyapp.com URL.

3. Establish the API Service Layer This creates a clean, dedicated place for all backend communication, making the code much easier to manage.

Create Axios Instance: In src/api/, create a file named axiosConfig.js. This file will set up a central axios instance that automatically uses the REACT_APP_API_BASE_URL from your .env file.

Define API Functions: In src/api/, create the templateService.js file. Here, you'll write the functions that will call your backend endpoints, like getTemplates() and uploadForAnalysis().

4. Implement Basic Error Handling & Logging Per your request, we'll set up a simple but effective way to handle errors.

Create a Toast Component: In src/components/ui/, create a basic Toast.jsx component. This component will be used to display subtle, simple error messages to the user when an API call fails.


Implement Console Logging: In your templateService.js functions, we will wrap all API calls in try...catch blocks. If an error occurs, we will show the toast notification to the user and log the detailed technical error to the browser's console. This provides the "log" the client can use for debugging without needing a complex external service.

By the end of this phase, you'll have a robust project foundation that is correctly configured for your AWS deployment target, with a clean structure ready for building the visual components.

## Phase 2 Checklist & Plan
Here is a step-by-step plan for building the static UI, including how we'll test each part.

### Step 1: Create the Main Application Layout
We'll start by creating the main frame of the application‚Äîthe header and content area‚Äîto ensure a consistent look on every page.

Implementation:

Create a Header.jsx component in src/components/common/. This will contain your app's title or logo.

Create a MainLayout.jsx component in src/components/layout/. This component will render the Header at the top and then render the specific page content below it.

Update App.jsx to wrap all your page routes within this MainLayout component.

Testing & Verification:

‚úÖ Visual Check: When you run the app, you should see your new header permanently fixed at the top of the page.

‚úÖ Navigation Check: As you navigate between the homepage (/) and the upload page (/upload), the content below the header should change, but the header itself should remain in place.

### Step 2: Build the Static Dashboard Page
Next, we'll build the main dashboard that users will see, which primarily consists of a grid of template cards.

Implementation:

Create a TemplateCard.jsx component in src/components/templates/. It will be a styled card that accepts props like a template name.

In src/pages/DashboardPage.jsx, create a hardcoded array of fake data (e.g., const mockTemplates = [{ id: 1, name: 'Monthly Business Review' }, { id: 2, name: 'Client Proposal' }];).

Use this mockTemplates array to render a grid of your TemplateCard components.

Add the styled + Upload New Template button to the page.

Testing & Verification:

‚úÖ Visual Check: The dashboard should display a styled grid of template cards, each showing the name from your hardcoded data, perfectly matching your UI design.

### Step 3: Build the Multi-Step Upload Workflow
This is the most interactive part of the static build. We'll create the three-step process for uploading a new template within a single page component.

Implementation:

In src/pages/UploadWorkflowPage.jsx, use a React state (useState) to track the current step (e.g., step 1, step 2, step 3).

Use conditional rendering to show the UI for the active step and hide the others.

Step 1 UI: Build the initial file upload screen with a prominent upload button or drag-and-drop area.

Step 2 UI: Build the placeholder review screen. Create a PlaceholderTag.jsx component in src/components/templates/ and use a hardcoded array of strings (e.g., ['name', 'date']) to display the tags.

Step 3 UI: Build the final save screen with the "Template Name" input and the "Save Template" and "Generate Now" buttons.

Testing & Verification:

‚úÖ Interaction Check: You should be able to click through the workflow. Clicking the "Upload" button takes you to step 2, and clicking "Confirm & Continue" takes you to step 3.

‚úÖ Visual Check: Each step should appear exactly as designed in your UI documents, with all buttons, inputs, and placeholder tags correctly styled.

After completing these steps, you will have a fully styled, clickable prototype of your application, ready for backend integration in Phase 3.

## The Goal of Phase 3 üîó
The goal of this phase is to systematically connect your frontend to your backend, replacing every piece of mock data and static functionality with live API calls. By the end of this phase, your application will be fully functional, capable of uploading, saving, listing, deleting, and generating presentations.

## Phase 3 Integration Plan & Checklist
Here is a step-by-step plan. We will focus on one feature at a time, implement the frontend logic, and verify it works before moving to the next.

### Step 1: Connect the Dashboard to GET /api/templates
First, we'll make the dashboard display real templates from your database.

Implementation:

In src/pages/DashboardPage.jsx, import getTemplates from your templateService.js file.

Use a useEffect hook to call this function when the component first loads.

Use a useState hook to store the fetched templates.

Replace the mockTemplates array with this new state variable. The component will now render real data.

Add loading and error states: display a spinner while fetching and an error message if the API call fails.

Verification:

‚úÖ Visual Check: The dashboard should now display the actual templates that exist in your PostgreSQL database. If the database is empty, it should show an empty screen (which we'll improve later) instead of the mock data.

### Step 2: Implement the Full Template Upload Workflow
This is the most complex step, connecting all three parts of the upload page to three different backend endpoints.

Implementation:

File Analysis (POST /api/upload): In UploadWorkflowPage.jsx, when a user selects a file in Step 1, we will call a new uploadForAnalysis function in templateService.js. This function will send the file and receive the list of placeholders, which we'll store in state.

State Management: The placeholder list from the API response will now populate the review screen in Step 2, replacing the mock data.

Template Saving (POST /api/save_template): In Step 3, when the user clicks "Save Template," we'll call a new saveTemplate function in templateService.js. This function must send multipart/form-data containing the template name, the final list of placeholders (as a JSON string), and the original file itself. On success, we will navigate the user back to the dashboard.

Verification:

‚úÖ End-to-End Test: Perform a full upload. Select a .pptx file, review the auto-detected placeholders, give it a name, and click "Save." You should be redirected to the dashboard, where your new template now appears in the list. Check your S3 bucket and database to confirm the records were created.

### Step 3: Implement Template Deletion (DELETE /api/templates/<id>)
Next, we'll activate the delete functionality on the dashboard.

Implementation:

Create a deleteTemplate function in templateService.js.

On the DashboardPage.jsx, add an onClick handler to the "delete" button (or the kebab menu option) on each TemplateCard.

This handler will show a confirmation modal ("Are you sure?"). If the user confirms, it will call the deleteTemplate function with the template's ID.

On success, it will refresh the list of templates to show that the item has been removed.

Verification:

‚úÖ Interaction Check: Go to the dashboard, delete a template, and confirm the action in the modal. The card should disappear from the UI. A subsequent page refresh should confirm it's gone. Check your database to confirm the deleted_at timestamp is set.

### Step 4: Implement the Presentation Generation Workflow
This final step connects the data entry form to the /generate endpoint and handles the file download.

Implementation:

Data Entry Page: We will create the DataEntryPage.jsx. This page will receive a templateId from the URL. It will fetch the template details (including its placeholders array) to dynamically build the form.

Asset Uploads (POST /api/assets/upload): For image placeholders, the file input's onChange handler will immediately call a new uploadAsset function in templateService.js. This function will upload the image and return the temporary s3_key, which we'll store in our form's state.

Generation (POST /api/generate): When the user clicks the final "Generate Presentation" button, we will call a generatePresentation function in templateService.js. This function will send a JSON payload containing the templateId and the data object (which includes the text values and the s3_keys for images).

File Download: The generatePresentation function must be configured to handle a blob response from the server. We will write the utility code to take this blob and trigger a browser download prompt for the user.

Verification:

‚úÖ End-to-End Test: Select a template from the dashboard. Fill out the dynamic form, including uploading an image. Click "Generate Presentation." A loading spinner should appear, followed by a browser download prompt for the finished .pptx file. Open the downloaded file to confirm all placeholders were correctly filled.

Test Plan: Image Search Feature
1. UI and Visual Testing (The "Look and Feel" Test)
This section focuses on ensuring the user interface looks correct in all states.

Initial State:

Navigate to the DataEntryPage.

Verify that the ImageUploader component correctly displays two distinct buttons: "Upload Image" and "Search Image".

Modal Appearance:

Click the "Search Image" button.

Verify the modal opens, is centered, and has the title "Search for an Image".

Verify it contains a search input field and a "Search" icon button.

Verify the footer contains a "Cancel" and a disabled "Confirm and Upload" button.

Component States:

Perform a search.

Verify that a skeleton loader (the pulsing grey boxes) appears while waiting for results.

Search for a term with no results (e.g., "asdfghjkl"). Verify the UI shows a message like "No images found for...".

Click on an image from the results. Verify it is highlighted with a distinct border (a blue or teal ring).

2. Functional "Happy Path" Testing (The "Does it Work?" Test)
This is the main end-to-end test to ensure the feature works as intended under normal conditions.

Navigate to the DataEntryPage.

Click the "Search Image" button to open the modal.

Type a valid search term (e.g., "Modern building") into the search bar and press Enter or click the search icon.

Verify that a grid of images appears.

Click on a single image to select it. Verify it becomes highlighted.

Click the "Confirm and Upload" button.

Verify the modal closes.

Verify the ImageUploader component on the DataEntryPage now shows a preview of the selected image.

Fill out all other required text fields on the form.

Click "Review and Generate" and proceed to the ReviewPage.

Verify that the thumbnail of the image you selected from the web is correctly displayed on the review page.

3. Edge Case and Negative Testing (The "What If?" Test)
This section tests how the feature handles non-standard user behavior.

Empty Search: Click the search button with an empty input field. Verify no search is performed.

Change of Mind: Open the modal, select an image, but then click "Cancel". Verify the modal closes and the ImageUploader is unchanged.

Click Outside: Open the modal and click the faded area outside of it. Verify the modal closes.

Reselection: Perform a search, select one image, then click a different image. Verify the selection highlight moves to the new image.

Regression Test: After testing the search feature, verify that the original "Upload Image" button still works correctly by selecting and uploading a file directly from your computer.

4. Error Handling Testing (The "What Breaks?" Test)
This is a critical step for a production-ready feature. Use your browser's Developer Tools (F12 > Network tab) to simulate network failures.

Search Fails:

In the Network tab, find a way to block requests. Right-click the search?q=... request and select "Block request URL".

Perform a new search.

Verify that the image grid area shows a clear error message (e.g., "Failed to fetch images.").

Upload Fails:

Unblock the search request and perform a successful search.

Now, block the /api/assets/upload_from_url request URL.

Select an image and click "Confirm and Upload".

Verify the modal does not close.

Verify a clear error message appears in the modal's footer (e.g., "Failed to upload the selected image.").

Completing this test plan will give you high confidence that the feature is clean, robust, and ready for your users.

a client-side filtering approach seems like the best fit. We'll fetch all templates once when the dashboard loads and then use React to filter the displayed list based on the user's search input directly in the browser.

Here‚Äôs the plan:

1. Frontend Changes (DashboardPage.jsx)
Add Search State:

Introduce a new state variable to hold the user's search query:

JavaScript

const [searchQuery, setSearchQuery] = useState('');
Add Filtered List State:

Introduce another state variable to hold the templates that match the search query. We'll keep the original templates state to hold the full list fetched from the API.

JavaScript

const [filteredTemplates, setFilteredTemplates] = useState([]);
Add Search Input UI:

Place a text input field near the top of the dashboard (e.g., below the header, above the grid).

Control its value using the searchQuery state.

Use an onChange handler to update searchQuery as the user types.

JavaScript

<input
  type="text"
  placeholder="Search templates..."
  value={searchQuery}
  onChange={(e) => setSearchQuery(e.target.value)}
  className="mb-4 p-2 border rounded w-full sm:w-1/2 md:w-1/3" // Example styling
/>
Modify Initial Data Fetch (useEffect):

When getTemplates successfully fetches data:

Update the main templates state with the full list (as it does now).

Also, update the filteredTemplates state with the same full list initially.

Implement Filtering Logic (useEffect):

Add a new useEffect hook that depends on searchQuery and the main templates list.

Inside this effect:

If searchQuery is empty, set filteredTemplates to the full templates list.

If searchQuery has text, filter the templates array. Check if each template.name (case-insensitive) includes the searchQuery.

Update filteredTemplates with the result of this filtering.

JavaScript

useEffect(() => {
  if (!searchQuery) {
    setFilteredTemplates(templates); // Show all if search is empty
  } else {
    const lowerCaseQuery = searchQuery.toLowerCase();
    const filtered = templates.filter(template =>
      template.name.toLowerCase().includes(lowerCaseQuery)
    );
    setFilteredTemplates(filtered);
  }
}, [searchQuery, templates]); // Re-run when search or original list changes
Update Rendering:

Change the part that maps templates to render TemplateCard components. Instead of mapping templates, map over filteredTemplates.

JavaScript

 // Old: {templates.map((template) => ( ... ))}
 // New:
 {filteredTemplates.map((template) => (
   <TemplateCard key={template.id} template={template} onDelete={openDeleteModal} />
 ))}
Handle "No Results":

Modify the renderContent function. If status is 'success' but filteredTemplates.length is 0 and searchQuery is not empty, display a "No templates found matching your search." message instead of the EmptyState component.

2. Backend Changes (routes.py) & API Service (templateService.js)
No changes needed! üéâ

The existing GET /api/templates endpoint already returns all non-deleted templates.

The getTemplates function in templateService.js already fetches this complete list.

Why this approach fits your requirements:
Clean & Less Complex: It keeps the logic contained mostly within the DashboardPage component. No complex backend search or database indexing is needed for this basic filtering.

Robust: Works reliably as long as the number of templates isn't excessively large (e.g., many thousands, which is unlikely for a personal tool).

Cost-Effective & Production Friendly: Minimizes backend load by fetching data only once per page load/refresh. This saves compute resources and potential costs.

Optimistic Update Friendly: Deleting a template already updates the local state (templates). The filtering logic will automatically work correctly with the updated list without needing extra API calls.

Responsive: Filtering happens instantly in the user's browser.

-----

## Code Report: Dashboard Search Feature Implementation

**File:** `src/pages/DashboardPage.jsx`

**Goal:** Add a client-side search functionality to filter the displayed template cards based on user input, with responsive UI adjustments and hover effects.

-----

### Step 1: Add State Variables

  * **Purpose:** Introduce state to manage the search input text and the list of templates to be displayed after filtering.
  * **Code Added:**
    ```jsx
    const [searchQuery, setSearchQuery] = useState('');
    const [filteredTemplates, setFilteredTemplates] = useState([]);
    ```

-----

### Step 2: Initialize Filtered Templates After Fetching

  * **Purpose:** Ensure all templates are displayed initially when data is successfully fetched.
  * **Code Added (inside the `fetchTemplates`'s `try` block):**
    ```diff
      const data = await getTemplates();
      setTemplates(data);
    + setFilteredTemplates(data); // Initialize filtered list
      setStatus('success');
    ```

-----

### Step 3: Implement Filtering Logic

  * **Purpose:** Add a `useEffect` hook to update the `filteredTemplates` list whenever the `searchQuery` or the original `templates` list changes.
  * **Code Added:**
    ```jsx
    useEffect(() => {
      if (!searchQuery) {
        setFilteredTemplates(templates);
      } else {
        const lowerCaseQuery = searchQuery.toLowerCase();
        const filtered = templates.filter(template =>
          template.name.toLowerCase().includes(lowerCaseQuery)
        );
        setFilteredTemplates(filtered);
      }
    }, [searchQuery, templates]);
    ```

-----

### Step 4: Add Search Input UI

  * **Purpose:** Add the text input field for the search bar, controlled by the `searchQuery` state. Render it conditionally.
  * **Code Added (within the `return` statement's header section):**
    ```jsx
    {status === 'success' && templates.length > 0 && (
      <div className="mb-6">
        <input
          type="text"
          placeholder="Search templates..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="p-2 border border-gray-300 rounded-lg w-full sm:w-1/2 md:w-1/3 lg:w-1/4 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent"
        />
      </div>
    )}
    ```

-----

### Step 5: Update Rendering to Use Filtered List

  * **Purpose:** Modify the rendering logic to map over `filteredTemplates` instead of the original `templates` state.
  * **Code Modified (inside `renderContent` function, `success` case):**
    ```diff
    - {templates.map((template) => (
    + {filteredTemplates.map((template) => (
        <TemplateCard key={template.id} template={template} onDelete={openDeleteModal} />
      ))}
    ```

-----

### Step 6: Handle "No Results Found"

  * **Purpose:** Display a specific message when a search yields no results, distinguishing it from the initial empty state.
  * **Code Modified (inside `renderContent` function, `success` case):**
    ```diff
      case 'success':
        if (templates.length === 0) {
          return <EmptyState />;
    +   } else if (filteredTemplates.length === 0 && searchQuery) {
    +      return (
    +        <div className="text-center text-gray-500 mt-8">
    +          No templates found matching "{searchQuery}".
    +        </div>
    +      );
        } else {
          return (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
              {filteredTemplates.map((template) => (
                 // ... TemplateCard
              ))}
            </div>
          );
        }
    ```

-----

### Step 7: Restructure Header and Apply Responsive Styles

  * **Purpose:** Rearrange the header elements (title, search bar, button) using Flexbox to match the design, and hide/show elements based on screen size.
  * **Code Modified (Header section in `return` statement):**
      * Wrapped title, search input div, and action buttons div in a main `flex flex-wrap justify-between items-center gap-4 mb-6` container.
      * Modified search input `div` classes to `hidden md:flex flex-grow justify-center max-w-lg relative`.
      * Added a new `div` for action buttons (`flex items-center gap-2 flex-shrink-0`).
      * Added a `<button>` for the search icon, visible only on small screens (`md:hidden`).
      * Defined `SearchIcon` and `PlusIcon` components.

-----

### Step 8: Add Icon Inside Search Input

  * **Purpose:** Place the `SearchIcon` visually inside the left part of the search input field.
  * **Code Modified (Search input block):**
      * Added `relative` class to the search input container `div`.
      * Added a new `div` *before* the input to hold the `SearchIcon`, styled with `absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400`.
      * Added `pl-10` to the input's `className` for padding.

-----

### Step 9: Verify and Adjust Input Padding

  * **Purpose:** Correct the overlap between the icon and the placeholder text by ensuring sufficient left padding on the input.
  * **Code Modified (Input element `className`):**
      * Confirmed/adjusted `pl-10` (or `pl-11`/`pl-12` if needed) was present in the input's class list.
    <!-- end list -->
    ```diff
    - className="p-2 pl-10 ..." // Example initial state
    + className="p-2 pl-10 ..." // Confirmed or adjusted value
    ```

-----

### Step 10: Add Hover Effects and Transitions

  * **Purpose:** Implement the teal border/shadow hover effect on the search bar and the color change on the icon.
  * **Code Modified:**
      * Added `group` class to the search input container `div`.
      * Added `group-hover:text-teal-500 transition-colors duration-300 ease-in-out` to the icon's `div`.
      * Added `hover:border-teal-500 hover:shadow-md transition-all duration-300 ease-in-out` to the input's `className`.

-----

This report covers all the significant changes applied to `DashboardPage.jsx` during this feature implementation.

Okay, aiming for a **smooth, flowing slide-and-fade** effect that's noticeable but **simple, clean, and production-friendly**.

Based on your components and requirements, using the **Framer Motion** library is the ideal approach. It integrates seamlessly with React and React Router, making complex animations like slide-and-fade relatively straightforward while remaining performant.

Here‚Äôs the plan:

-----

## 1\. Install Framer Motion

First, add the library to your frontend project:

```bash
npm install framer-motion
```

-----

## 2\. Modify `MainLayout.jsx` to Orchestrate Animations

We'll use Framer Motion's `AnimatePresence` component here. It detects when a direct child component enters or leaves the React tree and allows us to animate those transitions.

```diff
// src/components/layout/MainLayout.jsx

import React from 'react';
- import { Outlet } from 'react-router-dom';
+ import { Outlet, useLocation } from 'react-router-dom';
+ import { motion, AnimatePresence } from 'framer-motion';
import Header from '../common/Header';

+// Define the animation variants
+ const pageVariants = {
+   initial: {
+     opacity: 0,
+     x: '100vw', // Start off-screen to the right
+   },
+   in: {
+     opacity: 1,
+     x: 0, // Animate to on-screen
+   },
+   out: {
+     opacity: 0,
+     x: '-100vw', // Animate off-screen to the left
+   },
+ };
+
+// Define the transition properties
+ const pageTransition = {
+   type: 'tween', // Smooth interpolation
+   ease: 'anticipate', // Easing function for a slightly bouncy feel
+   duration: 0.4, // Animation duration in seconds
+ };


function MainLayout() {
+ const location = useLocation(); // Get current location for the key prop

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col"> {/* Added flex flex-col */}
      <Header />
      {/* AnimatePresence needs to wrap the part that changes */}
+     <AnimatePresence mode="wait"> {/* 'wait' ensures exit animation finishes first */}
        <main className="container mx-auto px-6 py-8 flex-grow"> {/* Added flex-grow */}
          {/* Child routes will be rendered here */}
          {/* Add motion.div wrapper with key, variants, and transition */}
+         <motion.div
+           key={location.pathname} // Unique key tells AnimatePresence when page changes
+           initial="initial"
+           animate="in"
+           exit="out"
+           variants={pageVariants}
+           transition={pageTransition}
+         >
            <Outlet />
+         </motion.div>
        </main>
+     </AnimatePresence>
    </div>
  );
}

export default MainLayout;

```

-----

## 3\. Explanation

  * **`AnimatePresence`**: This component from Framer Motion detects when its direct children are added or removed. We use `mode="wait"` so the old page finishes animating *out* before the new page animates *in*.
  * **`useLocation`**: We get the current URL `pathname` from React Router.
  * **`motion.div`**: This wraps the `<Outlet />`. It's the component that actually gets animated.
      * **`key={location.pathname}`**: This is crucial\! It tells `AnimatePresence` that the component *itself* has changed when the URL changes, triggering the enter/exit animations.
      * **`initial`, `animate`, `exit`**: These props tell `motion.div` which state from the `pageVariants` object to use for each phase (entering, visible, exiting).
      * **`variants={pageVariants}`**: Defines the styles for each animation state (`initial`, `in`, `out`). We set `opacity` for the fade and `x` (horizontal position) for the slide.
      * **`transition={pageTransition}`**: Defines *how* the animation happens (duration, easing type). `tween` with `anticipate` easing often gives a nice, smooth but slightly dynamic feel.
  * **CSS Changes**: Added `flex flex-col` to the outer div and `flex-grow` to `main` to ensure the layout behaves correctly, especially if pages have different heights.

-----

## Why this plan fits your requirements:

  * **Smooth and Flowing**: Framer Motion uses optimized animations (often hardware-accelerated), and the chosen `tween` and `anticipate` easing contribute to this feel.
  * **Slide and Fade**: The `pageVariants` explicitly define changes in both `opacity` (fade) and `x` position (slide).
  * **Noticeable but Simple**: A `0.4` second duration is quick but clearly visible. The animation logic is contained and doesn't complicate page components.
  * **Clean & Less Complex**: Framer Motion's declarative approach (`AnimatePresence`, `motion.div`, `variants`) keeps the animation logic tidy and separate from your page logic.
  * **Robust & Production Friendly**: It's a widely used, well-maintained library designed for performance in React apps. The impact on bundle size is reasonable.
  * **Cost-Effective**: All animation happens client-side; no backend resources are involved.

This setup provides the slide-and-fade effect specifically when navigating between routes rendered within your `MainLayout`.

Okay, I've reviewed the files. Based on your requirements for a clean, robust, and production-ready integration, here's the plan:

## Plan: Integrating the Trash Feature

This plan outlines the necessary steps to add a "Trash" view where users can see and restore soft-deleted templates.

***

### 1. Backend API Endpoints (Assumption)

First, ensure these two **new endpoints** exist on your Flask backend:

* `GET /api/templates/trash`: Fetches only the templates marked as deleted (`deleted_at IS NOT NULL`).
* `POST /api/templates/{templateId}/restore`: Updates a specific template's `deleted_at` status back to `NULL`.

***

### 2. API Service Layer Updates (`src/api/templateService.js`)

We'll add functions to interact with the new backend endpoints.

* **Add `getTrashedTemplates` function:**
    * Purpose: Fetch the list of soft-deleted templates.
    * Action: Makes a `GET` request to `/api/templates/trash`.
    * Returns: A promise resolving to an array of trashed template objects. Include standard error handling like in `getTemplates`.
* **Add `restoreTemplate` function:**
    * Purpose: Restore a specific template from the trash.
    * Action: Takes a `templateId` and makes a `POST` request to `/api/templates/{templateId}/restore`.
    * Returns: A promise resolving to the backend's success message. Include standard error handling.

***

### 3. Routing Setup (`src/App.jsx`)

We need a dedicated URL for the trash page.

* **Add New Route:** Define a new route within the existing `<Route path="/" element={<MainLayout />}>` block.
    * Path: `/trash`
    * Element: `<TrashPage />` (We'll create this component next).

***

### 4. Create Trash Page (`src/pages/TrashPage.jsx` - New File)

This page will display the trashed items.

* **Component Structure:** Create a new functional component `TrashPage`.
* **Data Fetching:**
    * Use `useState` to manage `trashedTemplates`, `status` ('loading', 'success', 'error'), and potential `toastMessage`.
    * Use `useEffect` and `useCallback` (similar to `DashboardPage`) to call `getTrashedTemplates` on component mount.
* **Rendering Logic:**
    * Implement `renderContent` function similar to `DashboardPage` to handle loading (Spinner), error (ErrorState), and success states.
    * If `status` is 'success' and `trashedTemplates` is empty, display a message like "Trash is empty."
    * If templates exist, map over `trashedTemplates` and render a `TemplateCard` for each.
* **Restore Action:**
    * Define a `handleRestore` function that takes a `templateId`.
    * This function will call `restoreTemplate(templateId)`.
    * On success:
        * Show a success toast ("Template restored.").
        * Optimistically update the UI by removing the restored template from the `trashedTemplates` state (`setTrashedTemplates`).
    * On failure: Show an error toast.

***

### 5. UI Integration and Navigation

Connect the new page and actions to the existing UI.

* **Header Link (`src/components/common/Header.jsx`):**
    * Add a new `NavLink` component within the navigation `div`.
    * `to="/trash"`
    * Text: "Trash" (or potentially use a trash icon).
    * Apply the same `style` and `className` logic as the other links for consistency and active state indication.
* **Dashboard Deletion (`src/pages/DashboardPage.jsx`):**
    * Locate the `handleDeleteConfirm` function.
    * **Update Toast:** Change the success `setToastMessage` call from `'Template deleted successfully!'` to `'Template moved to trash.'`.
    * *Verification:* Confirm it already uses the `deleteTemplate` service function (which maps to the backend's soft-delete endpoint). The existing optimistic update (`setTemplates`) is correct.
* **Template Card (`src/components/templates/TemplateCard.jsx`):**
    * **Add Props:** Modify the component to accept two new optional props: `isTrashContext` (boolean) and `onRestore` (function).
    * **Conditional Actions (Inside the Card):**
        * **Kebab Menu:**
            * When `isTrashContext` is `true`, replace the "Delete" menu item with a "Restore" menu item.
            * The "Restore" item's `onClick` should call `onRestore(template)` and close the menu.
            * Consider hiding the "Edit" option in the trash context if it doesn't make sense.
        * **Hover Overlay:**
            * When `isTrashContext` is `true`, change the main hover button text from "Use Template" to "Restore".
            * The `onClick` or `Link` target for this button should also call `onRestore(template)`. (Decide if you want a button *or* menu item for restore, probably not both overlay button *and* menu item).
    * **Passing Props:**
        * In `DashboardPage.jsx`, render `<TemplateCard ... onDelete={openDeleteModal} />` (no changes needed here).
        * In the new `TrashPage.jsx`, render `<TemplateCard ... isTrashContext={true} onRestore={handleRestore} />`.

### 6. Final Touches

* **Toast Messages (`src/components/ui/Toast.jsx` & Calling Pages):** Ensure appropriate success/error messages appear for both moving to trash and restoring. Pass the correct `type` ('success' or 'error') to the Toast component.
* **Styling:** Ensure the "Trash" link in the header and the elements on the `TrashPage` match the application's overall style.

This plan creates a dedicated page for trashed items, reuses the existing `TemplateCard` component with minor modifications via props, updates the API service layer, and integrates the flow into the navigation and user feedback mechanisms.

Code Report: Trash Feature Integration (Soft Delete & Restore)Date: October 27, 2025Objective: Implement a soft-delete ("Trash") functionality allowing users to move templates to a temporary trash area instead of immediate permanent deletion, with the ability to restore them. Trashed items are automatically permanently deleted after 30 days via S3 lifecycle rules (backend configuration).1. Backend Modifications (app/api/routes.py)Two new API endpoints were added, and one existing endpoint was modified to support the soft-delete logic.Added GET /api/templates/trash:Purpose: Fetches a list of templates that have been soft-deleted.Implementation: Queries the templates table for records where the deleted_at column IS NOT NULL. Returns a JSON array of these records.Added POST /api/templates/<template_id>/restore:Purpose: Restores a soft-deleted template.Implementation: Takes a template_id via the URL path. Verifies the template exists and deleted_at IS NOT NULL. Updates the corresponding record in the templates table, setting deleted_at = NULL. Returns a success message.Modified DELETE /api/templates/<template_id>:Purpose: Changed from permanent deletion to soft deletion.Implementation: Instead of deleting the database record, this endpoint now updates the deleted_at column of the specified template record to the current timestamp (CURRENT_TIMESTAMP). It also includes logic to move the corresponding file in S3 to a designated trash/ prefix (handled by s3_service.move_file_to_trash). Returns a message indicating the item was moved to trash.2. API Service Layer Modifications (src/api/templateService.js)Functions were added to interact with the new backend endpoints.Added getTrashedTemplates():Purpose: Makes a GET request to /api/templates/trash.Returns: Promise resolving to an array of trashed template objects. Includes error handling.Added restoreTemplate(templateId):Purpose: Makes a POST request to /api/templates/{templateId}/restore.Returns: Promise resolving to the backend success message. Includes error handling.Modified deleteTemplate(templateId):Purpose: Updated the user-facing error message thrown on failure to reflect "move template to trash" instead of "delete template". The endpoint called remains /api/templates/{templateId} (DELETE method).3. Frontend Routing Modifications (src/main.jsx)Routing was updated to include the new Trash page, using the createBrowserRouter configuration.Added Trash Route: A new route object was added to the children array of the main layout route definition:{
  path: '/trash',
  element: <TrashPage />,
}
Imported TrashPage: The TrashPage component was imported.Note: Routing logic previously in App.jsx using <Router>/<Routes>/<Route> components is now superseded by the createBrowserRouter definition in main.jsx.4. New Frontend Component (src/pages/TrashPage.jsx)A new page component was created to display and manage trashed items.Functionality:Fetches trashed templates using getTrashedTemplates on component mount.Manages loading, success, and error states for the data fetching process.Displays a Spinner during loading, an ErrorState component on fetch failure (with retry), and an EmptyTrashState component if no trashed items are found.Renders a grid of TemplateCard components, passing the fetched trashedTemplates.Provides a handleRestore function which calls the restoreTemplate API service. On success, it shows a toast notification and optimistically removes the restored template from the local state for immediate UI feedback.TemplateCard Usage: Passes isTrashContext={true} and onRestore={handleRestore} props to the TemplateCard components.5. UI Component ModificationsExisting UI components were updated to integrate the feature.src/components/common/Header.jsx:Added a NavLink component pointing to /trash.Includes a TrashIcon alongside the text "Trash".Uses existing styling logic for hover and active states.src/components/templates/TemplateCard.jsx:Props Added: Component now accepts isTrashContext (boolean, default false) and onRestore (function).Conditional Rendering (Hover Button): The main button shown on hover now displays "Restore" (and calls onRestore) if isTrashContext is true, otherwise it displays "Use Template" (as a Link).Conditional Rendering (Kebab Menu): The entire kebab menu button (MoreVerticalIcon) and its associated dropdown are now hidden (display: none effectively via conditional rendering) if isTrashContext is true. If isTrashContext is false, the menu shows "Edit" and "Delete" options as before.UI Polish: Added pointer-events-none to the hover overlay and kebab button when hidden (opacity 0) to prevent interaction with invisible elements. Added aria-label to the kebab button.src/pages/DashboardPage.jsx:Modal Text: Updated the confirmation modal text (title, body, confirm button) displayed when deleting a template to clearly state "Move to Trash" and mention the 30-day auto-deletion.Toast Message: Updated the success toast message shown after clicking the confirm button in the modal to "Template moved to trash." Added state (toastType) to handle error toasts correctly if the API call fails.SummaryThe Trash feature provides a safety net against accidental deletion by implementing a soft-delete pattern. Templates moved to trash are viewable on a dedicated /trash page and can be restored. The integration leverages existing components (TemplateCard, Toast, Modal) with conditional logic based on context (dashboard vs. trash view) and relies on new backend endpoints for data fetching and state modification. Automatic permanent deletion is handled by backend S3 configuration.

Okay, thank you for clarifying those points. Based on your answers, here is my understanding of the user journey for list placeholders:

---

## User Journey: List Placeholders

### Part 1: Template Upload & Review (Implicit Handling)

1.  [cite_start]**Upload**: The user uploads a `.pptx` file containing various placeholders, including some formatted like `{{list:some_items}}`[cite: 563].
2.  [cite_start]**Analysis**: The backend analyzes the file using `extract_placeholders` and identifies placeholders like `some_items` as having the `type: "list"`[cite: 566, 302, 303, 304, 305].
3.  **Review Placeholders (Upload Step 2)**:
    * [cite_start]The user arrives at the "Review Placeholders" screen[cite: 568].
    * They see all detected placeholders listed, including those identified as lists (e.g., `some_items [list]`).
    * [cite_start]**Crucially, the user *does not* define the specific choices (like "Option A", "Option B") for the list placeholder at this stage.** The system simply recognizes its *type* as "list" based on the `{{list:...}}` syntax in the PPTX[cite: 569, 570, 571]. [cite_start]The user can still add/remove placeholders as usual[cite: 570, 571].
4.  [cite_start]**Save Template (Upload Step 3)**: The user names and saves the template[cite: 574, 575]. [cite_start]The backend saves the template metadata, including the placeholder list with their names and types (e.g., `{"name": "some_items", "type": "list"}`)[cite: 581, 582].

---

### Part 2: Generating a Presentation (Data Entry)

1.  [cite_start]**Select Template**: The user selects the template containing the `{{list:some_items}}` placeholder from their dashboard[cite: 590, 591].
2.  **Fill Details (Data Entry Form)**:
    * [cite_start]The user is taken to the dynamic `DataEntryPage`[cite: 594].
    * The frontend checks the `type` for each placeholder.
    * **Scenario A (Predefined List):** If the placeholder name (`some_items`) matches a *known list* predefined in the frontend's (or backend's) configuration:
        * The UI displays a group of **checkboxes** corresponding to the predefined choices (e.g., ‚òê Choice A, ‚òê Choice B, ‚òê Choice C).
        * An additional checkbox labeled **"Other"** is always included in this group.
        * If the user checks the "Other" box, a **text input field appears immediately beside it**, allowing them to type a custom value.
        * The user can select any combination of the predefined checkboxes and also fill in the "Other" text box.
    * **Scenario B (Unknown/New List):** If the placeholder name (`some_items`) is *not* recognized as having predefined choices:
        * [cite_start]The UI displays a **multi-input field** (similar to the current design for `{{project_updates}}` [cite: 449, 450, 451, 452]), allowing the user to add multiple text items freely using an "+ Add Item" button.
    * [cite_start]The user fills in all other text and image placeholders as usual[cite: 595, 596, 597].
3.  [cite_start]**Review Entries**: The user proceeds to the `ReviewPage`[cite: 601]. The summary displays the selections for the list placeholder.
    * For **Scenario A**, it might show something like: "Some Items: Choice A, Choice C, *Custom Value*".
    * For **Scenario B**, it might show: "Some Items: Item 1, Item 2, Item 3".
4.  [cite_start]**Generate Presentation**: The user clicks "Generate Presentation"[cite: 601].
    * [cite_start]The frontend sends the data to `POST /api/generate`[cite: 608]. The data for `some_items` will likely be an array of strings containing the labels of the selected predefined checkboxes *plus* the text entered in the "Other" box (if any) for Scenario A, or the list of strings entered in the multi-input field for Scenario B.
5.  **Backend Processing**:
    * [cite_start]The backend fetches the template and receives the data array for `some_items`[cite: 609, 610].
    * [cite_start]The `pptx_service.generate_presentation` function finds the `{{list:some_items}}` shape in the presentation[cite: 611].
    * If the received array for `some_items` is empty or wasn't provided, it replaces the placeholder shape's text with the word "**None**".
    * [cite_start]If the array contains items, it clears the placeholder text and inserts each item from the array as a **separate bullet point** within that shape's text frame[cite: 611, 613].
6.  [cite_start]**Download**: The final `.pptx` file is generated and sent to the user for download[cite: 604, 614].

---

Okay, let's lay out a plan to integrate the list placeholder feature cleanly into your application. We'll do this in phases, focusing on minimal complexity first while keeping it production-ready.

## Phase 1: Backend Preparation (Database & Generation Logic)

**Goal:** Ensure the backend can store the `list` type and correctly generate bullet points in the PowerPoint from an array of data.

1.  **Verify Database Schema:**
      * [cite\_start]Confirm that the `placeholders` column in your `templates` table is `JSONB`[cite: 6112]. [cite\_start]This structure already supports storing the `"type": "list"` information identified during the upload analysis[cite: 6448]. No database schema change is needed initially.
2.  **Enhance Generation Service (`pptx_service.py`):**
      * [cite\_start]Modify the `generate_presentation` function[cite: 6162].
      * Inside the loop processing shapes, add logic to detect if a placeholder is a list type (e.g., check `placeholder['type'] == 'list'` if you pass the full placeholder info, or just check the incoming `data` structure).
      * **Input Handling:** Expect the corresponding value in the `data` dictionary for a list placeholder (e.g., `data['nearby_amenities']`) to be an **array of strings**.
      * **Bullet Point Logic:**
          * If the array exists and is *not empty*:
              * [cite\_start]Clear the existing text/placeholder from the shape's text frame[cite: 6162].
              * Add the **first item** from the array as the text for the first paragraph (level 0).
              * Iterate through the **remaining items** in the array, adding a **new paragraph** for each one, setting its text and ensuring `level=0` for standard bullets.
              * Consider disabling text frame auto-fitting (`tf.auto_size = MSO_AUTO_SIZE.NONE`) to prevent text shrinking if the list is long.
          * If the array is *empty* or *missing*: Replace the placeholder shape's text with the word "**None**", as requested.
      * [cite\_start]**Keep Existing Logic:** Ensure this new list logic doesn't interfere with the existing text [cite: 6162] [cite\_start]and image replacement logic[cite: 6162]. Image/List placeholders likely need `continue` statements after handling to prevent text replacement logic from running on them.
3.  **Refine Placeholder Extraction (`pptx_service.py`) (Confirmation):**
      * [cite\_start]Double-check that `extract_placeholders` correctly identifies `{{list:name}}` and returns `{"name": "name", "type": "list"}`[cite: 6448]. [cite\_start]This seems correct based on the provided code[cite: 6448].

-----

## Phase 2: Frontend Implementation (Data Entry UI & State)

**Goal:** Update the data entry form to conditionally render the correct input UI for list placeholders and manage the state accordingly.

1.  **Predefined Choices Configuration (Frontend):**
      * **Decision:** For the least complexity initially, let's define the mapping of *known* list placeholder names to their choices directly in the frontend.
      * **Action:** Create a configuration object (e.g., in a constants file or directly in `DataEntryPage.jsx`) like:
        ```javascript
        const PREDEFINED_LIST_CHOICES = {
          nearby_amenities: ["Supermarket", "Park", "Bus Stop", "Gym"],
          // Add other known list placeholders here
        };
        ```
2.  **Modify Data Entry Page (`DataEntryPage.jsx`):**
      * [cite\_start]**Conditional Rendering:** Inside the `map` function rendering form fields[cite: 6162]:
          * Check `ph.type === 'list'`.
          * If it is a list, check if `ph.name` exists as a key in `PREDEFINED_LIST_CHOICES`.
          * **If Predefined:** Render a new component (or inline JSX) that displays:
              * Checkboxes for each choice in `PREDEFINED_LIST_CHOICES[ph.name]`.
              * An "Other" checkbox.
              * A text input that is *conditionally displayed* only when the "Other" checkbox is checked.
          * **If Not Predefined:** Render a multi-input component (you might adapt the logic used for `project_updates` if that exists, or create a new one) allowing the user to add/remove text items.
      * **State Management (`formData`):**
          * For **predefined lists:** The state for this placeholder (e.g., `formData.nearby_amenities`) needs to store an **array** of selected choice strings. When "Other" is checked and text is entered, add that text to the array. Ensure you handle checking/unchecking correctly.
          * For **dynamic lists:** The state needs to store an **array** of the strings entered by the user in the multi-input fields.
      * [cite\_start]**Form Validation (`isFormValid`):** Adjust the validation logic [cite: 6162] to correctly check if list placeholders (both types) have at least one selection/entry if they are considered required.
3.  **Update API Service (`templateService.js`):**
      * [cite\_start]In the `generatePresentation` function[cite: 6162], ensure that the `data` payload being sent correctly includes the arrays of strings for the list placeholders based on the `formData` state. No complex transformation should be needed if the state is already storing arrays.

-----

## Phase 3: Frontend Review & Polish

**Goal:** Ensure the review page displays the list data correctly and the overall flow is smooth.

1.  **Modify Review Page (`ReviewPage.jsx`):**
      * [cite\_start]In the section that displays the summary of entered data[cite: 6162]:
          * Check if the value for a key corresponds to an array (you might need to check the original `template.placeholders` type information passed in the state).
          * If it's an array (our list data), format it for display. Instead of just showing the raw array, maybe join the items with commas (e.g., "Supermarket, Park, Library") or display them as a small bulleted list within the summary row.
          * Handle the display of an empty list appropriately (perhaps showing "None").
2.  **Refine Styling & UX:**
      * Ensure the checkbox group, "Other" input, and multi-input fields are styled consistently with the rest of the application.
      * Test the user experience of adding/removing items in the dynamic list and selecting/unselecting checkboxes.

-----

## Phase 4: Testing & Refinement

**Goal:** Thoroughly test all scenarios and ensure robustness.

1.  **End-to-End Testing:**
      * **Scenario A (Predefined):**
          * Upload a template with `{{list:nearby_amenities}}`.
          * Go to Data Entry, select some predefined checkboxes, check "Other", and type a custom value.
          * Verify the Review Page displays all selections correctly.
          * Generate the presentation and confirm the output has the correct bullet points.
          * Test selecting *only* "Other".
          * Test selecting *only* predefined choices.
          * Test selecting *nothing* and ensure "None" appears in the generated PPTX.
      * **Scenario B (Dynamic):**
          * Upload a template with an *unknown* list placeholder, e.g., `{{list:meeting_attendees}}`.
          * Go to Data Entry, use the multi-input to add several names.
          * Verify the Review Page displays the names correctly.
          * Generate the presentation and confirm the output has the correct bullet points.
          * Test adding *no* items and ensure "None" appears in the generated PPTX.
2.  **Edge Case Testing:**
      * Test placeholders with names containing underscores or numbers.
      * Test interactions with existing text and image placeholders.
3.  **Code Review & Refinement:** Review the implementation for clarity, efficiency, and adherence to your project's coding standards.

This phased approach introduces the necessary backend capability first, then builds the core frontend UI, refines the review step, and concludes with thorough testing. It starts with the simplest configuration approach (frontend-defined choices) for known lists.

## Feature Code Report: Presentation Download Workflow

**Date:** [Current Date, e.g., 2023-10-27]
**Feature:** New Presentation Download Workflow (Dedicated Download Tab)
**Author (Code Reviewer):** [Your Name/AI Assistant]

---

### I. Overview

This report details the implementation and successful resolution of the new presentation download workflow. The primary goal was to improve user experience by decoupling the file generation and download process from the main application tab. Upon clicking "Generate," a new browser tab now opens to manage the download, while the original tab redirects to the dashboard, allowing users to continue interacting with the application without waiting.

### II. Implemented Changes

**1. New Component: `src/pages/DownloadPage.jsx`**
    * **Purpose:** A dedicated, minimal page to handle the entire file generation and download lifecycle.
    * **Functionality:**
        * Reads generation parameters (template ID, form data) from `sessionStorage`.
        * Initiates the `generatePresentation` API call.
        * Manages and displays three distinct UI states: "Loading" (with spinner), "Success" (with checkmark and download prompt), and "Error" (with `cat.png` and error message).
        * Automatically triggers the browser's file download for successful generations.
        * Provides a fallback "Click here" link for manual download if automatic fails.
        * Crucially, uses a `useRef` flag (`hasInitialized`) to prevent duplicate API calls and `sessionStorage` removal in React's `StrictMode` (resolving the initial flicker bug).
    * **Status:** Production Ready.

**2. Router Configuration: `src/main.jsx`**
    * **Purpose:** To define the new route for the `DownloadPage`.
    * **Changes:** Added a new top-level route `/downloading` which directly renders `<DownloadPage />`.
    * **Impact:** This placement ensures the `DownloadPage` renders outside the `MainLayout`, achieving the desired headerless, minimal design.
    * **Status:** Production Ready.

**3. `ReviewPage` Modification: `src/pages/ReviewPage.jsx`**
    * **Purpose:** To initiate the new download workflow.
    * **Changes:**
        * Modified `handleGenerate` function to:
            * Store the necessary `templateId` and `formData` into `sessionStorage` under the key `pptxDownloadData`.
            * Open the new `/downloading` URL in a new browser tab (`window.open`).
            * Immediately redirect the current tab to the Dashboard (`/`) using `useNavigate`.
        * Removed previous local state variables and logic related to download progress/errors, as these are now handled by `DownloadPage`.
        * **Fix:** Integrated `useNavigate` hook and corrected its usage (resolved a `Maps is not defined` error found during review).
    * **Status:** Production Ready.

### III. Key Issues Addressed During Development/Review

* **Flickering Download Page (Error -> Success):**
    * **Root Cause:** React's `StrictMode` caused `DownloadPage`'s `useEffect` to run twice. The first run consumed and removed the `sessionStorage` data, leading the second run to find no data, triggering an error state. When the first API call eventually succeeded, it would then update to success, causing a visible flicker from error to success.
    * **Resolution:** Implemented a `useRef` flag (`hasInitialized`) within `DownloadPage.jsx`'s `useEffect` to ensure the critical `sessionStorage` read/remove and API call logic only executes once per component lifecycle, even under `StrictMode`.

* **`Maps is not defined` Error on `ReviewPage`:**
    * **Root Cause:** A typo in `ReviewPage.jsx`'s `handleGenerate` function attempting to use an undefined `Maps` variable instead of the `navigate` function from `useNavigate`.
    * **Resolution:** Correctly imported and initialized `useNavigate` and used the `navigate('/')` function for redirection.

### IV. Testing & Validation

The feature underwent comprehensive end-to-end testing, including:
* **Happy Path:** Confirmed seamless transition from Review Page to Dashboard, automatic new tab opening, `DownloadPage` loading state, automatic file download, and `DownloadPage` success state.
* **Fallback Download Link:** Verified the "Click here" link correctly re-triggers download.
* **Negative Path:** Confirmed correct `DownloadPage` error state display upon backend API failure.
* **Edge Cases:**
    * Direct navigation to `/downloading` correctly shows "No generation data found" error.
    * Concurrent generations in separate tabs function independently without data conflicts.
    * Browser tab closure during generation handled gracefully.

### V. Conclusion

The new presentation download workflow is successfully implemented and validated. The solution is clean, robust, and significantly enhances the user experience by providing a dedicated and informative download process that doesn't block the main application flow. The identified and resolved issues during development (StrictMode flicker, ReviewPage redirection) have ensured a high-quality, production-ready feature.

## Code Report: Navigation Blocker & Unsaved Changes

**Date:** [23-10-25]
**Feature:** Warn user before accidental navigation on data-entry and review pages.
**Author (Code Reviewer):** Gemini

---

### I. Overview

This report details the implementation of a navigation-blocking feature to prevent users from accidentally losing their work. The feature is active on two key pages: `DataEntryPage` (to protect unsaved form data) and `ReviewPage` (to protect an un-generated presentation session).

The implementation relies on the custom `useNavigationBlocker` hook, which leverages `react-router-dom`'s `useBlocker`, and the existing `Modal` component.

---

### II. Implementation Details

#### 1. File: `src/pages/DataEntryPage.jsx`

* **Goal:** Block navigation only if the user has entered or uploaded data (the form is "dirty") and is not intentionally submitting.

* **State Changes:**
    * Added `isDirty (boolean)` state.
    * Added `isSubmitting (boolean)` state to manage the "safe exit."

* **Logic:**
    * The `isDirty` state is set to `true` in all data-handling functions: `handleInputChange`, `handleListChange`, and `handleImageUploadSuccess`.
    * The blocker is activated with `useNavigationBlocker(isDirty && !isSubmitting)`. This declaratively handles the core logic.
    * The "safe exit" (`handleReview` button) was refactored:
        * `onClick` now only sets `setIsSubmitting(true)`.
        * A `useEffect` hook, dependent on `[isSubmitting]`, now handles the programmatic navigation to the review page. This resolves any race conditions.

* **UI:**
    * The `<Modal>` component was added and is displayed when the hook's `showModal` is `true`.
    * It's wired to `handleCancelNavigation` and `handleConfirmNavigation` from the hook.

#### 2. File: `src/pages/ReviewPage.jsx`

* **Goal:** Block navigation if the user tries to leave the page *before* generating the presentation or going back to the form.

* **State Changes:**
    * Added `isNavigatingSafely (boolean)` state, default `false`.
    * Added `safeNavigationPath (string | null)` state to store the destination of a safe exit.

* **Logic:**
    * The blocker is activated with `useNavigationBlocker(!isNavigatingSafely)`.
    * The "safe exits" (`handleGenerate` and `handleBackToForm`) were refactored to *only* set state:
        * `handleGenerate` sets `isNavigatingSafely(true)` and `setSafeNavigationPath("/")`.
        * `handleBackToForm` sets `isNavigatingSafely(true)` and `setSafeNavigationPath("/generate/...")`.
    * The "Back to Form" `<Link>` was converted to a `<button>` to use the `onClick` handler.
    * A `useEffect` hook, dependent on `[isNavigatingSafely, safeNavigationPath]`, performs the safe navigation *after* the state has updated and the blocker is disarmed.

* **UI:**
    * The `<Modal>` component was added with custom text ("Not Generated Yet?") and wired to the blocker hook's props.

---

### III. Bugs Resolved

1.  **`ReviewPage` Race Condition:** Fixed a critical bug where `Maps()` was called in the same handler as `setIsNavigatingSafely(true)`. This caused the blocker to fire before the state update was processed. Resolved by moving navigation logic into a `useEffect` hook triggered by the state change.
2.  **`ReviewPage` Crash:** Fixed a `ReferenceError: useEffect is not defined` by adding the missing `useEffect` import from `react`.

### IV. Referenced Files (No Changes)

* `src/hooks/useNavigationBlocker.js`: Provided the core blocking mechanism.
* `src/components/ui/Modal.jsx`: Provided the UI for the warning.
* `src/main.jsx`: Router (no changes needed).
* `src/App.jsx`: (Not in use by `main.jsx` router, no changes).

### V. Conclusion

The feature is implemented correctly and is production-ready. The state-first approach (setting a flag, then navigating in an effect) is robust and correctly handles the component lifecycle and router-blocking race conditions.


Journey 1: The "In-Place Edit" (Quick Fixes)
Scenario: The user is on the ReviewPage and notices a typo in the "Client Name" and wants to change the "Company Logo".

Part A: Editing a Text Field
Start Edit: The user sees "Client Name: Acme Corp" but it should be "Acme Inc.". They click the small "Edit" icon next to that row.

Enter Edit Mode:

Frontend: The read-only text "Acme Corp" instantly transforms into an active text input field, pre-filled with "Acme Corp".

Simultaneously, two new buttons, "Update" and "Cancel", appear in that row.

The main "Generate Presentation" button at the bottom of the page becomes disabled (grayed out) to prevent generation during an edit.

Make Change: The user types "Acme Inc." into the input field.

Confirm Change: The user clicks the "Update" button.

Save State:

Frontend: The "Update" and "Cancel" buttons disappear. The input field reverts to read-only text, now displaying "Acme Inc."

The page's internal data (formData state) is updated with the new value.

This new data is saved to sessionStorage to keep the "memory" feature in sync.

The "Generate Presentation" button becomes enabled again.

Backend: No backend call is made. This is a 100% client-side operation.

Part B: Editing an Image Field
Start Edit: The user clicks the "Edit" icon next to the "Company Logo" image preview.

Enter Edit Mode:


Frontend: An image upload modal immediately opens, showing the ImageUploader component (with its "Upload" and "Search" options).

The "Generate Presentation" button is disabled.

Make Change: The user searches for a new logo, selects it, and clicks "Confirm and Upload" in the modal.

Save State:


Backend: The frontend sends the new image to the POST /api/assets/upload endpoint, which saves it to S3 and returns a new s3_key.


Frontend:

The modal closes.

The ReviewPage receives the new s3_key and updates its formData state.

This new data is saved to sessionStorage.

The image preview on the ReviewPage refreshes to show the new logo.

The "Generate Presentation" button is re-enabled.

Part C: Canceling an Edit
Start Edit: The user clicks the "Edit" icon next to "Client Name."

Make Change... or Not: The user types "asdf..." and then realizes they made a mistake.

Cancel: The user clicks the "Cancel" button (or presses the Esc key).

Revert State:

Frontend: The "Update" and "Cancel" buttons disappear. The input field reverts to its original read-only text, "Acme Corp".

The component's state is not changed.

The "Generate Presentation" button is re-enabled.

Journey 2: The "Edit All" (Major Changes)
Scenario: The user is on the ReviewPage and realizes they need to change three text fields and add two more list items. The "In-Place Edit" would be too slow.

Start Edit: The user clicks the "Edit All" button (this button has replaced the "‚Üê Back to Form" button).

Navigate Back:

Frontend: The app navigates the user back to the DataEntryPage for this template (e.g., /generate/123).

This is a "safe" navigation, so the navigation blocker is not triggered.

Reload Form with Data:

Frontend (DataEntryPage): The page loads. Its useEffect hook runs and finds the existing data in sessionStorage.

The entire form is repopulated with all the data the user had previously entered (text, lists, and image previews are all restored).

Make Changes: The user is now on the familiar full-page form. They edit the three text fields and add their two new items to the list component.

Return to Review: The user clicks the "Review and Generate" button.

Save and Navigate:

Frontend (DataEntryPage): The component saves all the new data to sessionStorage and navigates the user back to the ReviewPage.

Final Confirmation:

Frontend (ReviewPage): The page loads, reads the updated data from sessionStorage, and now displays all the corrected information.

User: The user confirms everything is perfect and clicks "Generate Presentation".

## Code Report: Form Session Memory & In-Place Edit Feature
Date: November 1, 2025

1. Overview
This report details the implementation of two major frontend features:

Form Session Memory: A new mechanism to persist user data on the DataEntryPage and ReviewPage. This solves the critical bug where users would lose all their data (including text and image uploads) upon page refresh or navigation.

In-Place Editing: A new feature on the ReviewPage that allows users to edit individual fields one by one (via modals or in-line) without having to return to the full form.

The core of this solution was to stop passing invalid blob: URLs and instead use s3_keys as the single source of truth, with a new backend endpoint to securely fetch viewable URLs.

2. New Architectural Additions
To support these features in a robust and secure way, several new files were added:

Backend Endpoint (app/api/routes.py)

GET /api/assets/view-url: A new endpoint was added to securely generate an S3 pre-signed URL for a given s3_key.

Security: This endpoint validates that the requested key must start with temp/ to prevent unauthorized access to other files in the S3 bucket.

Frontend API Service (src/api/templateService.js)

getAssetViewUrl(key): A new function was added to call the /api/assets/view-url endpoint, providing a clean way for frontend components to fetch secure URLs.

New Frontend Components & Hooks

src/components/common/S3Image.jsx: A new "smart" component that takes an s3Key as a prop. It handles its own loading, error, and success states by fetching its viewable URL from the backend via getAssetViewUrl.

src/hooks/useReviewPageEditor.js: A new hook that manages the global edit state of the ReviewPage, ensuring only one row can be edited at a time and disabling other UI elements.

src/components/common/EditableReviewRow.jsx: A new "smart row" component for the ReviewPage. It renders the read-only view (using <S3Image />) and conditionally renders the correct edit UI (a text input or a modal) when the "Edit" button is clicked.

3. Modifications to Existing Files
src/pages/DataEntryPage.jsx

Removed the imagePreviews state. The formData state, which stores s3_keys for images, is now the single source of truth.

fetchDetails was updated to load data from sessionStorage on mount. It validates the templateId in the session against the URL templateId to prevent data from one template leaking into another.

A useEffect hook was added to save formData and template to sessionStorage on every change, ensuring the session is always up-to-date.

handleImageUploadSuccess was simplified to only save the s3_key to formData.

The ImageUploader component prop was updated to pass initialS3Key={formData[ph.name]} instead of the invalid initialPreviewUrl.

src/pages/ReviewPage.jsx

Critical Bug Fix: Corrected a React "Rules of Hooks" violation by moving useNavigationBlocker and the navigation useEffect to the top level of the component, preventing conditional hook calls.

The useEffect data fetch was refactored to load all data from sessionStorage instead of location.state, making the page fully refresh-proof.

The imagePreviews state was removed.

The render logic was replaced with a map that uses the new <EditableReviewRow /> component for each placeholder.

Added the handleUpdateItem function, which is called by EditableReviewRow to update both the component state and sessionStorage.

The "Back to Form" button was renamed to "Edit All".

The "Generate Presentation" button is now correctly disabled via the isEditing flag from the useReviewPageEditor hook.

src/components/common/ImageUploader.jsx

The useEffect hook that runs on mount now correctly uses the initialS3Key prop to call getAssetViewUrl and fetch a secure preview URL.

handleFileSelect and handleModalImageSelect were updated to only call onUploadSuccess with the s3_key, removing the temporary blob: URL.

src/components/templates/TemplateCard.jsx

An onClick handler was added to the "Use Template" <Link>.

This handler calls sessionStorage.removeItem(DATA_ENTRY_SESSION_KEY), ensuring every new session starts with a fresh, empty form.

src/pages/DownloadPage.jsx

This file was modified to also call sessionStorage.removeItem(DATA_ENTRY_SESSION_KEY) when generation begins, clearing the form memory after a successful submission.

src/components/common/MultiTextInput.jsx & CheckboxGroupWithOther.jsx

Minor logic bugs were fixed in the onChange handlers to prevent inputs from disappearing or behaving inconsistently while the user was typing.

4. Key Bugs Resolved
net::ERR_FILE_NOT_FOUND (Broken Images): FIXED. This was the most critical bug. It was resolved by completely removing the blob: URL logic and using the s3_key as the single source of truth, with previews rendered via the new S3Image component.

Form Data Lost on Refresh/Navigation: FIXED. All form data is now securely persisted in sessionStorage, providing a seamless user experience when navigating or refreshing.

React Crash (Rules of Hooks Violation): FIXED. The white screen crash on the ReviewPage was resolved by moving all hooks to the top level of the component.

UX Bugs: Fixed minor but annoying bugs in list and checkbox components that caused jarring behavior during user input.

Radio Button addition:- 

Phase 1: Backend Update (The "Engine")
Goal: Teach the backend to understand and generate the new placeholder. This is a very minor change.


File to Modify: Backend/app/services/pptx_service.py 

Action:


No change needed for extract_placeholders(): Your current regex re.compile(r'\{\{(?:(\w+):)?(\w+)\}\}')  is already smart enough. It will see {{choice:project_status}} and correctly identify it as {"name": "project_status", "type": "choice"}.

Modify generate_presentation(): We just need to tell the "text replacement" logic to also handle the "choice" type.

Find the line that defines text_pattern:


text_pattern = re.compile(r'\{\{(?:text:)?(\w+)\}\}') 

Change it to include choice: as a valid prefix: text_pattern = re.compile(r'\{\{(?:text:|choice:)?(\w+)\}\}')

Result: The backend is now ready. The generate_presentation function will see the {{choice:project_status}} placeholder, find the project_status key in your data (e.g., "On Track"), and perform a simple text replacement, just like a normal {{text}} placeholder.

Phase 2: Frontend Configuration (The "Data")
Goal: Define the options that will appear for your new radio button groups.


File to Modify: Frontend/src/constants/listChoices.js 

Action:

At the end of the file, add a new exported constant specifically for your "choice" options. This keeps it separate and clean from your "list" (checkbox) options.

Add your new placeholder names and their options here. For example:

JavaScript

// ... (existing PREDEFINED_LIST_CHOICES) ...

export const PREDEFINED_CHOICE_OPTIONS = {
  project_status: ["On Track", "At Risk", "Delayed"],
  another_choice: ["Option A", "Option B", "Option C"],
};
Result: Your frontend now knows what options to show for {{choice:project_status}}.

Phase 3: Frontend UI (The "View")
Goal: Create the new radio button component and render it on the Data Entry & Review pages.

New File: Frontend/src/components/common/RadioButtonGroupWithOther.jsx

Action: Create this new component.


Plan: It will be very similar to your existing CheckboxGroupWithOther.jsx  but modified for single-select (radio buttons).

It will accept placeholderName, choices, value (which will be a single string, e.g., "On Track"), and onChange.

It will render <input type="radio"> for each item in choices.

It will include an "Other" radio button.

It will have its own local state to manage the "Other" text input's visibility and value.

When any standard radio is clicked, it will call onChange(placeholderName, "Selected Choice").

When the "Other" radio is clicked or its text is changed, it will call onChange(placeholderName, "Custom Other Text").

Per your requirement, all options will be unselected by default if value is "".


File to Modify: Frontend/src/pages/DataEntryPage.jsx 

Action: Teach the form to render your new component.

Plan:

Import your new RadioButtonGroupWithOther component and the PREDEFINED_CHOICE_OPTIONS constant.


Modify fetchDetails: In the reduce function that builds initialData, make sure choice types are initialized to an empty string "" (just like "text" and "image" types).


Modify Form Rendering: In the .map() loop that renders the form fields, find the ph.type === "list" block.

Add a new else if (ph.type === "choice") block.

Inside this block:

Check if PREDEFINED_CHOICE_OPTIONS[ph.name] exists.

If YES: Render your new <RadioButtonGroupWithOther /> component.


If NO: Render a standard <input type="text" ... />. This perfectly handles your fallback requirement.


Add Handler: Create a new handler function handleRadioChange (or just reuse handleInputChange ) to update the formData state with the single string value.


File to Modify: Frontend/src/components/common/EditableReviewRow.jsx 

Action: Teach the "Review Page" how to display and edit the new "choice" type.

Plan:

Read-Only View: No change needed. Since the value is just a string (e.g., "On Track"), the existing renderReadOnlyView logic for "text" types will display it perfectly.


Edit View (Your Requirement): We will use a modal, as it's the most robust and consistent UI pattern you already use for images and lists.

Modify handleEditClick: Add "choice" to the condition that opens the modal.

Change this line:


if (type === "image" || type === "list") { 

To this: if (type === "image" || type === "list" || type === "choice") {

Modify renderModalEditView:

Import RadioButtonGroupWithOther and PREDEFINED_CHOICE_OPTIONS.

Add an else if (type === "choice") block inside the modal's render logic.

Inside this block: Just like on the DataEntryPage, check if PREDEFINED_CHOICE_OPTIONS[placeholderKey] exists.

If YES: Render <RadioButtonGroupWithOther />.

If NO: Render a simple <input type="text" ... />.

Wire these components up to currentValue and handleListChange (which can be renamed to handleModalInputChange since it just calls setCurrentValue).

## Code Report: 'Choice' Placeholder (Radio Button) Feature

**Date:** November 6, 2025
**Feature:** Implement new `{{choice:name}}` placeholder type.
**Goal:** Render predefined radio button groups (with an "Other" option) on the data entry page, or a fallback text input if no choices are defined. Ensure this is supported in both the data entry form and the review page's "in-place edit" modal.

---

### I. Backend Modifications (`app/services/pptx_service.py`)

* **File:** `app/services/pptx_service.py`
* **Change 1: `extract_placeholders`**
    * **Status:** ‚úÖ No change needed.
    * **Reason:** The existing regex `re.compile(r'\{\{(?:(\w+):)?(\w+)\}\}')` correctly identifies `{{choice:name}}` and parses it as `{"name": "name", "type": "choice"}`.
* **Change 2: `generate_presentation` (Text Replacement Logic)**
    * **Status:** ‚úÖ Modified.
    * **Reason:** Debugging revealed that placeholders (e.g., `{{choice:PD_or_Full_PP_or_House_holder}}`) were split across multiple text runs in the PPTX XML, causing formatting issues.
    * **Implementation:**
        1.  Replaced the simple "Run-by-Run" logic with a robust **Hybrid Method**.
        2.  **Attempt 1:** The code first loops through each `run` individually. If a full placeholder is found in a single run, it's replaced, preserving all mixed formatting.
        3.  **Attempt 2 (Fallback):** If no replacements were made (indicated by `was_run_replacement_made = False`) but the paragraph *still* contains a placeholder (`'{{' in para.text`), the code correctly identifies it as a "split-run" placeholder.
        4.  It then falls back to the "Whole Paragraph" method: it saves the font from the first run, rebuilds the full text, replaces all placeholders, and writes the new text into a single, cleared run. This ensures all placeholders are replaced, even if it means sacrificing mixed formatting in that specific paragraph.

---

### II. Frontend Modifications

#### 1. Configuration (`src/constants/listChoices.js`)

* **Status:** ‚úÖ Modified.
* **Change:** Added a new exported constant `PREDEFINED_CHOICE_OPTIONS` to store the options for `choice` placeholders, keeping them separate from the `list` (checkbox) options.

#### 2. New Component (`src/components/common/RadioButtonGroupWithOther.jsx`)

* **Status:** ‚úÖ New File.
* [cite_start]**Purpose:** Created a new component modeled after `CheckboxGroupWithOther.jsx` [cite: 3521-3543] but for single-select (radio buttons).
* **Logic:**
    * Manages its own state for `otherText` and `isOtherSelected`.
    * Includes an `useEffect` hook to sync its internal state with the parent `value` prop, correctly handling "Other" values vs. standard choices.
    * Provides handlers (`handleStandardChange`, `handleOtherRadioChange`, `handleOtherTextChange`) to manage user input and call the parent `onChange` prop with a single string value.
* **Bug Fix:** Resolved a flicker bug by updating the `useEffect` logic to correctly handle the `!value` (empty) state, preventing it from incorrectly setting `isOtherSelected(false)` when the "Other" button was just clicked.

#### 3. Data Entry (`src/pages/DataEntryPage.jsx`)

* **Status:** ‚úÖ Modified.
* **Changes:**
    1.  **Imports:** Imported `RadioButtonGroupWithOther` and `PREDEFINED_CHOICE_OPTIONS`.
    2.  **State Init:** Updated `fetchDetails` to initialize `choice` types to `""` (empty string) in `initialData`, just like `text` types.
    3.  **Handler:** Added `handleSimpleChange` to accept the single string value from the new radio component and update `formData`.
    4.  **Rendering:** Added an `else if (ph.type === "choice")` block to the form's render map.
        * If `PREDEFINED_CHOICE_OPTIONS[ph.name]` exists, it renders `<RadioButtonGroupWithOther />`.
        * If not, it correctly renders a fallback `<input type="text" />`.

#### 4. Review & Edit (`src/components/common/EditableReviewRow.jsx`)

* **Status:** ‚úÖ Modified.
* **Changes:**
    1.  **Imports:** Imported `RadioButtonGroupWithOther` and `PREDEFINED_CHOICE_OPTIONS`.
    2.  **Read-Only View:** No change needed; the simple string `value` is correctly rendered by the "text" logic.
    3.  **Edit Handler:** Updated `handleEditClick` to include `"choice"` in the condition to open the modal.
    4.  **Modal View:** Updated `renderModalEditView` to include an `else if (type === "choice")` block, which (like the Data Entry page) renders either `<RadioButtonGroupWithOther />` or a fallback `<input type="text" />`.
    5.  **Modal Render Bug Fix:** The final `return` statement's JSX was updated to include the "choice" type, fixing a bug where the modal would not render.
        * **From:** `{(type === "image" || type === "list") && renderModalEditView()}`
        * **To:** `{(type === "image" || type === "list" || type === "choice") && renderModalEditView()}`

üó∫Ô∏è Latest User Journey: Editing a Template
This journey details the "Happy Path" for a successful edit, as well as the specific error cases and edge cases you defined.

Part 1: The "Happy Path" (Successful Edit)

Start (Dashboard): The user is on the main dashboard (DashboardPage.jsx). They see a grid of their active templates.


Action: The user hovers over a TemplateCard. They click the "kebab" menu (three dots) and select the "Edit" option .



Frontend Response (Modal): A modal window appears (Modal.jsx). It displays a small form with two fields:

Name: A text input, pre-filled with the template's current name.

Description: A text area, pre-filled with the template's current description (or an empty string).

User Input: The user changes the Name (e.g., to "Quarterly Review") and adds a Description (e.g., "Standard template for all Q1-Q4 client-facing reports").

Saving: The user clicks the "Save" button in the modal.

Full-Stack Process:

Frontend: The browser sends a PUT request to a new backend endpoint (e.g., PUT /api/templates/123) with the new name and description.


Backend: The backend API (routes.py) receives the request .

It performs validation and confirms the name is not empty (as you requested).

It queries the database to ensure no other template is already using that name (as you requested).

Finding no errors, it runs an UPDATE command on the templates table in the PostgreSQL database, saving the new name and description.

Frontend: The frontend receives a success (e.g., 200 OK) response. The modal closes, and a success toast appears ("Template updated").

Final Result (Dashboard): The user is back on the dashboard. The TemplateCard they just edited has instantly updated.

The title now shows "Quarterly Review".

The description below the title now shows "Standard template for all Q1-Q4..." but is truncated with an ellipsis (...) to prevent overflowing the card, as per your requirement.

Part 2: Error & Edge Scenarios (Based on Your Rules)
Scenario A: User saves with an EMPTY name.

Action: The user deletes all text from the "Name" field and clicks "Save".

Result (Rule 3): The save is prevented. The modal remains open, and a validation error appears directly within the modal (e.g., "Name cannot be empty"). No API call is made.

Scenario B: User saves with a DUPLICATE name.

Action: The user renames Template A to "Old Template Name", which is already used by Template B, and clicks "Save".

Result (Rule 2): The frontend sends the PUT request. The backend detects the name conflict and returns an error (e.g., 409 Conflict). The modal remains open, and an error message appears: "A template with this name already exists."

Scenario C: User CANCELS an edit.

Action: The user types a new name and description, but then clicks the "Cancel" button or clicks outside the modal.

Result (Rule 4): The modal immediately closes. No warning is shown, and the changes are discarded.

Scenario D (Excluded): User is in the TRASH.


Action: The user navigates to the /trash page (TrashPage.jsx).

Result (Rule 5): The user hovers over a template card. The kebab menu (and therefore the "Edit" button) does not appear. The TemplateCard component, using its isTrashContext prop , only shows the "Restore" action. Editing is impossible from this page.

## Feature Documentation: Trash S3/DB Synchronization

### 1. Feature
Trash Feature: S3/DB Synchronization ("Just-in-Time Gateway")

### 2. Objective
[cite_start]To resolve the desynchronization problem between the PostgreSQL database and the S3 bucket's 30-day lifecycle rule[cite: 907, 908, 909]. [cite_start]This plan ensures a user cannot restore an "orphaned" database record whose corresponding S3 file has already been permanently deleted, preventing a future `500 Internal Server Error` during the generation step[cite: 3535].

### 3. Problem Statement
* [cite_start]The `TrashPage.jsx` [cite: 213] [cite_start]populates its list of items by calling `GET /api/templates/trash`[cite: 202, 3586].
* [cite_start]This backend endpoint queries the PostgreSQL database for all records with a non-NULL `deleted_at` timestamp[cite: 3587].
* [cite_start]An independent S3 Lifecycle Policy permanently deletes files in the `trash/` prefix after 30 days[cite: 907, 908, 909].
* **Conflict:** The database can (and will) contain records for templates that no longer exist in S3. [cite_start]If a user restores this "orphaned" record, the `POST /api/templates/<id>/restore` [cite: 203] [cite_start]call will *succeed* (as it only updates the DB [cite: 3580][cite_start]), but the application will fail with an error when the user later attempts to `POST /api/generate`[cite: 3535].

### 4. Proposed Solution
Implement a "Just-in-Time Gateway" check on the **restore endpoint**.

[cite_start]The `POST /api/templates/<id>/restore` [cite: 203] route will be modified. Before restoring the item in the database, it will first make a quick check to S3 to verify the file still exists.

* If the file **exists**, the restore proceeds normally.
* If the file **does not exist** (i.e., it was purged by the S3 rule), the backend will instead *delete* the orphaned database record and return a specific `410 Gone` error to the frontend, allowing the UI to handle the cleanup gracefully.

### 5. Implementation Plan

#### Backend (`app/services/s3_service.py`)
1.  **Create Helper Method:** Add a new, reusable method to the `S3Service` class.
    * **Method:** `def file_exists(self, s3_key: str) -> bool:`
    * **Logic:**
        * Use `self.s3_client.head_object(Bucket=self.bucket_name, Key=s3_key)`.
        * Wrap this call in a `try...except ClientError as e`.
        * If `e.response['Error']['Code'] == '404'`, return `False`.
        * If no exception, return `True`.
        * If another `ClientError`, re-raise it.

#### Backend (`app/api/routes.py`)
1.  [cite_start]**Modify `restore_template` Route:** Update the logic for `POST /api/templates/<int:template_id>/restore`[cite: 203, 3577].
    * [cite_start]**Step 1:** Fetch the template from the DB `WHERE id = %s AND deleted_at IS NOT NULL`[cite: 3579]. If not found, return `404` as usual.
    * **Step 2:** Get the `s3_key` from the template record.
    * **Step 3 (The Gateway):** Call `s3_service.file_exists(s3_key)`.
    * **Step 4 (If `False`):** The file is gone.
        * Run `DELETE FROM templates WHERE id = %s` to clean the orphaned record.
        * `db.commit()`.
        * Return `jsonify({"error": "This template has been permanently deleted."}), 410`.
    * **Step 5 (If `True`):** The file exists.
        * [cite_start]Proceed with the *original* restore logic: `UPDATE templates SET deleted_at = NULL WHERE id = %s`[cite: 3580].
        * `db.commit()`.
        * [cite_start]Return `jsonify({"message": "Template restored successfully."}), 200`[cite: 3583].
    * Ensure all logic is wrapped in a `try...except...finally` block to handle DB rollbacks and close the cursor.

#### Frontend (`src/pages/TrashPage.jsx`)
1.  [cite_start]**Modify `handleRestore`:** Update the `catch` block in the `handleRestore` function[cite: 219].
    * [cite_start]The `restoreTemplate(templateId)` [cite: 207] service call needs to handle the new `410` error.
    * **Logic:**
        ```javascript
        try {
          await restoreTemplate(templateId);
          // ... (existing success logic: toast, optimistic removal)
        } catch (error) {
          if (error.response && error.response.status === 410) {
            // Case 1: File is permanently gone
            setToastMessage("Template permanently deleted and removed from trash.");
            setToastType("error");
            // Still remove from UI, as it's now gone from the DB
            setTrashedTemplates(prev => prev.filter(t => t.id !== templateId));
          } else {
            // Case 2: Any other error (e.g., 500)
            setToastMessage("Failed to restore template. Please try again.");
            setToastType("error");
          }
        }
        ```

### 6. Acceptance Criteria
* **AC-1 (Normal Restore):** A user restores a template deleted < 30 days ago. The restore succeeds, and the template moves from `/trash` to the dashboard.
* **AC-2 (Orphaned Restore):** A user attempts to restore a template deleted > 30 days ago (whose file was purged from S3).
    * The user clicks "Restore".
    * The backend returns a `410` error.
    * The frontend shows an error toast: "Template permanently deleted and removed from trash."
    * The template card is removed from the `TrashPage` UI.
    * The template does *not* appear on the `DashboardPage`.  