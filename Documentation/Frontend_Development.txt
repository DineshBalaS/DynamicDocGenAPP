Frontend Development Goal Checklist
Phase 1: Project Setup & Foundation üèóÔ∏è (Day 1)
This phase establishes a solid, scalable foundation for your entire application.

[ ] Initialize the React Project:

In your root project folder, run npx create-react-app frontend to create the React application.

[ ] Clean Up Boilerplate:

Remove the default logo, App.test.js, and unnecessary CSS from App.js and index.css to start with a clean slate.

[ ] Install Core Dependencies:

Install the essential libraries for routing, API communication, and upload progress:

Bash

npm install axios react-router-dom
[ ] Establish Folder Structure:

Inside the frontend/src/ directory, create the following folders to keep your code organized:

pages/: For full-page components (Dashboard.js, UploadPage.js, etc.).

components/: For smaller, reusable components (ProgressBar.js, ErrorMessage.js, etc.).

api/: For handling all communication with your Flask backend.

[ ] Configure Environment Variables for Production Readiness:

Create a file named .env in the frontend/ root directory. This file must be in your .gitignore.

Inside .env, add the URL for your local backend:

REACT_APP_API_BASE_URL=http://127.0.0.1:5000
Create a second file named .env.example with the same variable but without a value. This file will be committed to Git and serves as a template for deployment.

REACT_APP_API_BASE_URL=
Why this is crucial: When you deploy to AWS Amplify or Render, you will set REACT_APP_API_BASE_URL to your live backend URL (e.g., https://pptx-backend.onrender.com). This allows you to switch between local development and production without ever changing your code.

Phase 2: Static UI Components & Styling üé® (Day 2-3)
Build the complete user interface from your UI image using fake, hardcoded data. The goal is to perfect the visual aspect before making it functional.

[ ] Set Up Routing:

In App.js, use react-router-dom to set up the routes for each distinct page in your design (e.g., /, /upload, /review-placeholders, etc.).

[ ] Build Reusable Components:

Based on your UI image, create common components in the components/ folder. At a minimum, you will need:

ProgressBar.js: A component that can show upload progress.

ErrorMessage.js: A component to display API errors.

TemplateCard.js: A component for the template tiles on the dashboard.

[ ] Create Static Pages:

Create the following components inside the pages/ directory, styling them to match your UI image and using hardcoded data:

Dashboard.js: Display a grid of TemplateCard components with fake data.

UploadWorkflowPage.js: Build the multi-step UI for uploading, reviewing placeholders, and saving the template.

DataEntryFormPage.js: Create the dynamic form, passing it a fake array of placeholders to render the various input types.

Phase 3: API Service Layer üîå (Day 4)
Create a dedicated, clean layer for handling all backend communication.

[ ] Create API Service File:

Inside frontend/src/api/, create a file named templateService.js.

Using axios, create and export async functions for each backend endpoint (e.g., getTemplates, uploadForAnalysis, saveTemplate, uploadAsset, generatePresentation).

Configure an axios instance to automatically use the REACT_APP_API_BASE_URL from your .env file.

For the file upload functions, make sure to include the onUploadProgress config so you can feed the progress data to your ProgressBar.js component.

Phase 4: Integration & Dynamic Functionality üîó (Day 5-7)
This is where the app comes to life. You'll replace all the fake data with live data from your backend.

[ ] Connect the Dashboard:

In Dashboard.js, use a useEffect hook to call the getTemplates() function on page load.

Store the results in a state variable (useState) and pass the data to your TemplateCard components.

Wire up the "Delete" button on each template to call the corresponding delete function and refresh the list.

[ ] Implement the Full Upload Workflow:

Connect the UploadWorkflowPage.js to the uploadForAnalysis() and saveTemplate() service functions.

Pass the real-time progress of the upload to your ProgressBar.js component.

Use the placeholder list returned from the backend to populate the review step.

[ ] Implement the Generation Workflow:

In DataEntryFormPage.js, when a user uploads an image asset, call the uploadAsset() function and store the returned s3_key in your component's state.

Connect the final "Generate Presentation" button to the generatePresentation() function, ensuring it sends the correct template_id and all user data (including image keys).

Implement the logic to handle the file blob response from the backend and trigger the browser's download prompt.

Phase 5: Production Polish ‚ú® (Day 8)
This phase focuses on making the application feel robust and professional.

[ ] Refine Loading States:

Ensure the ProgressBar.js is used for all file uploads.

For actions without trackable progress (like fetching templates or generation), show an indeterminate progress bar or a subtle loading animation to give the user clear feedback.

[ ] Implement Global Error Handling:

Wrap all API calls in try...catch blocks. If an error occurs, store the error message in state and display it to the user in your ErrorMessage.js component in a clear, non-intrusive way (e.g., a toast notification or a message bar).

[ ] Final Responsive Styling:

Review the entire application on different screen sizes (desktop, tablet, mobile) and ensure the layout is clean and usable on all devices.

Phase 6: Deployment Preparation üöÄ (Day 9)
Final checks to ensure a smooth, one-click deployment.

[ ] Build for Production:

Run npm run build to create a highly optimized production build of your application in the build/ folder.

[ ] Verify Deployment Settings:

For AWS Amplify/Render: Connect your Git repository. The service will likely auto-detect that it's a React app and set the build command to npm run build. Your only manual step will be to add the REACT_APP_API_BASE_URL environment variable in the service's configuration dashboard and point it to your live backend's URL.

[ ] Update Documentation:

Add a section to your main README.md explaining how to set up and run the frontend, including the need to create a .env file and list the required variables.